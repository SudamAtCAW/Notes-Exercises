Cypress Important Topics
Understand the Framework
Understand the folder structure 
where the environment variables are getting saved
purpose of
index.js
plugins.js
supports.js
fixtures
Understand the folder structure and environment configuration.ts


How Cypress is different from selenium:
Cypress gives us completes framework., Faster than selenium, More stable, Cypress can test and mock APIs.It doesn't 
need test environments.
It doesn't support IE and Safari.
Asynchronous code
No Mobile but Mobile view
Single domain and single tab
Not friendly with iframes.

Preparaing Developement Environment:
Install Chrome browser, Node.js, Git, IDE(VS code)

Clone the Application from the Repo:

Open a new floder for storing the project in it. Open that folder in cmd and run the command "git clone url" to clone the
 repo in your local system.
After cloning open that folder in Vs code and in terminal run "npm install" which will look into the dev dependencies
of package.json file and will download all the required dependencies
To start the application run the command "npm start"
After executing this command you can run the cloned application on your local port 4200

Cypress Installation:

In the terminal run the command "npm install cypress --save-dev" which will save cypress as a dev dependency in the 
package.json file

Open the cypress by running the command "npx cypress open"

Difference between npm and npx

npm is used to download javaScript packages from Node Package Manager , we can run applications locally by npm start.
by adding a command and key in the scripts block of package.json file

npx is used to execute javaScript packages downloaded by npm.

Folder Structure:
Whenever we open Cypress for the first time it will create a cypress folder in the root of our project
Under cypress we will get 3 other folders. e2e, fixtures and support

Under support we have commands and e2e file, 
e2e is the very first file that is executed by cypress, when cypress is initilized. Here we can import commands ,
event listeners, and custom packages.
in commands.js we will store our custom commands

Fixtures folder:
It represents the place where we can store our json files. it can be used when we are working with the apis

e2e:
In this folder we store our tests.

cypress.config.js:
This is the place where we configure the behaviour of the framework, different parameters.

Cypress Configuration:

In will be only done in cypress.config.js
here we can define our base url or local host port address.
Spec Pattern:
Cypress follows the cy.js or cy.ts pattern. We will be using a traditional naming convention spec.js
In the specPattern key we can add this value specPattern: "cypress/e2e/**/*.{js,jsx,ts,tsx,feature}"
In the begining of the brackets we can remove cy from it which is shown in the cypress configuration documentation
Now we can include any spec pattern.

excludeSpecPattern:

excludeSpecPattern: ['**/1-getting-started/*', '**/2-advanced-examples/*']

it will ignore the specified files and only show our test cases.

View Port:
view port will control the resolution of the screen of cypress

In e2e folder we can create tests with the name of test.spec.js or test.cy.js and it is only possible because of 
the spec pattern declared in the cypress.config.js
                                                  
Cypress 9 vs Cypress 10:
The integration folder in cy9 has been changed to e2e in cy10   
The index.js file under support folder in cy9 has been changed to e2e.js. bUt  The function still remains the same.
The plugins folder in cy9 doesn't exist in cy10
In cy9 there was a examples folder which contained some demo test cases.In cy10 the demo tests are under e2e folder
In cy9 the name of the config file was cypress.json but in cy10 it is cypress.config.js
The base URL and is moved inside the e2e block in cy10
View port is like a global config(not only for e2e for all i.e unit testing and e2e), that is why it is out side of the
the e2e block

Cypress removed the plugins folder that had index.js in it.
in that index.js we had one function module.exports which took two parameters on and config. Inside of this function
we can add our plugins.

module.exports  = (on, config) =>{

//initialPlugin(on, config);
//on("task", pearcyHealthCheck);
//return config;
}

In cy10 those settings moved to cypress.config.js Inside et2e block we need to create setupNodeEvents

setupNodeEvents(on, config) =>{
//initialPlugin(on, config);
//on("task", pearcyHealthCheck);
//return config;
}

Inside of the setupNodeEvents we can put all those settings that we were putting in index.js of plugins folder

In cy9 we could all the test by clicking a single button but in cy10 they have removed that button

DOM Terminology:

HTML DOM consists of HTMLtags, HTML Attributes and Attribute Values
HTML Tag Names:
div comes with opeening tag and closing tag
input comes with self closing tag

HTML Attributes Names 
Atributes can be found inside tags, usually they are in red colour.Some tag have some value and some doesn't
Some tag names are
data-cy
id
nbinput
placeholder
type

id and class are also html attribute names, they have a special role in html structure
class can have multiple values and separated by a space
HTML Tag Values:
They are assigned to attribute names. 

TABLE:
<tbody role> </tbody>
they ahve rows <tr> </tr>
rows have columns like <td> </td>
The values in between angle braces (>here<) is plain text values for that column. It is not visible all of the time.
If there are 3 dots in between angle braces that means it has some nested contents inside it

Relation between the web elements:
All elements located above our key element is parent element, 
All elements which are inside eour key element is child element

Sibling Element:
The elements whcih are aat the same stage as the key element is in.

Test Structure:
Every test will start with describe("abc") or context("abc").
In describe block we can add some description about our test, and then open a call back function with a body
In that body we will create a it block which will contain a description about the test. Again it will have a call 
back function with a body.
 We can add as many tests as we want in the describe block.
We can also create multiple describe blocks. We can also put describe inside another describe block.
describe('Test Scenario', () => {

  it('test case desc', () => {
    //repetative code(log in)
  });
});

beforeEach("abc", () =>{

}):
It is the code for every task. Inside the before each we can put some repeatative code ewquired for each test like 
log in function. By the help of this we don't need to copy and past the same code for each of the it blocks.
The beforeEach can only work insdie the describe block.

Types of Locators:
While writing our tests on the top of our code we can mention reference type as cypress. bY which vs code will support
and tell us the cypress methods.
Cypress uses the JQuerry selector engine. Knowing it will bw helpful in cypress.
Cypress doesn't have the xpath.

/// <reference types="cypress" />

A cypress statement always starts with cy

cy.visit("/")  // we can mention / as our base url when we are running the application on local host
      .contains("Forms")
      .click()
      .get(".menu-title")
      .contains("Form Layouts")
      .click()

      //By Tag Name, we dont need to specify any additional data to tell cypress that it is tag name
      .get("input")

      //By Id, while getting an element by id we have to add it with a # symbol ("#inputEmail")
      .get("#inputEmail")

      //By Class name, we have add a . (dot) in front of the class name
      .get(".input-full-width")

      //By Attribute name, we have to specify the attribute name inside square braces with in quotes
      .get("[placeholder]")

      //By Attributr name and value, same as attribute name, only the attribute value will be within double quotes
      .get('[placeholder="Email"]')

      //By Class value, here we have to provide the class name and value with in square brackets within doible quotes
      .get('[class="input-full-width size-medium shape-rectangle"]')

      //By Tag name and Attribute with value, make sure the inside and outside bracket quotes are different from each other
      .get('input[placeholder="Email"]') // give the tag name and attribute and value within quotes inside square brackets.

      //By two different attributes, just and each of the attributes in one square bracket
      .get('[placeholder="Email"][type="email"]')

      //By tag name, Attribute with value, ID and class name, add each of the elements respective data which is needed for
cypress to identify them
      .get('input[placeholder="Email"]#inputEmail.input-full-width')

      //The most recomended way, create your own attribute by adding it in the source code. 
When you mention your data locator no dev will change it.
      .get('[data-cy="imputEmail1"]');


While getting an element alwas use cy.contains or custom locatiors, 
While using text locators always look inti the dom for better understaiding. if it found multiple attributes

When we use cy.contains it will get the first match that it finds on the web page. 
We can provide more than one parameter to get the exact match of the desired element.
 cy.contains('[status="warning"]','Sign in').click()
Here we are telling sypress that find the web element that contains attribute "status" with value "warning" and then 
which contains Sign In

If a button doesn't contain any unique identifiers then try to find Unique identifiers in that section or parent element

cy.get('#inputEmail3') //getting an element by id
      .parents('form')  //travelling up by parent command
      .find('button') //finding the button
      .should('contain','Sign in')  //asserting the button

First find any element which has an Id. Then travel up by parents command and use find command to locate the button.
You can also add assertions in that button.

Find command is to only find child elements inside parent elements.
parents method is to locate parents element from the current element which you are in .

We can also use the find method to find an element which doesn't have any unique identifiers.

Saving The Subject of the Command: (Then and wrap methods)

     //cy.contains('nb-card','Using the Grid').find('[for="inputEmail1"]').should('contain','Email')
    // cy.contains('nb-card','Using the Grid').find('[for="inputPassword2"]').should('contain','Password')
    // cy.contains('nb-card','Basic form').find('[for="exampleInputEmail1"]').should('contain','Email address')
    // cy.contains('nb-card','Basic form').find('[for="exampleInputPassword1"]').should('contain','Password')

The issue with above written code is , it is repetative,

The selenium Way
const firstForm = cy.contains('nb-card','Using the Grid') //storing the web element in a variable
const secondForm = cy.contains('nb-card','Basic form') //storing the web element in a variable

finding the web elements:
firstForm.find('[for="inputEmail1"]').should('contain','Email')
firstForm.find('[for="inputPassword2"]').should('contain','Password')
secondForm.find('[for="exampleInputEmail1"]').should('contain','Email address')

the above code won't be working in cypress because javascript is asynchronous, we can not save the context/object/result of the 
command.

Cypress Style:
 .then Enables you to work with the subject yielded from the previous command.
 Whenever we use .then function , the parameter of the function becomes a jquery object(not a cypress object anymore)

cy.contains('nb-card','Using the Grid').then(firstForm =>{
        //this is a jquery method, here we are saving the webelements data and passing the data in a parameter to a 
        //call back function,  the benifit of using .then is it will only execute when cypress locates the web element
        //by this way we can store the context/object of the command
        const firstEmail=firstForm.find('[for="inputEmail1"]').text()
        //finding a web element  by using the parameter and converting it's data into text and storing it in a variable
        const firstPassword=firstForm.find('[for="inputPassword2"]').text()
        //by converting the data into text we will  be able to make assertions on it
        //expect is a chai assertion command
        expect(firstEmail).to.equal('Email');
        //cy.get(firstEmail).click()
        expect(firstPassword).to.equal('Password')

When making assertions  with JQuery methods we have to use chai library 
when making assertions with cypress elements we have to use should

To use the variables from then function can only be done by creating another nested function inside then. If we declare
the method outside of then we will get referencce error.

To convert the Jquery format into cypress format we use the .wrap method on the result from the then function
 cy.wrap(secondForm).find('[for="exampleInputEmail1"]').should('contain','Email address')

Invoke Command:
With the help of this this command, we don't have to call the text method for each of the element.
cy.get('[for="exampleInputEmail1"]').invoke('text').then(text =>{
      expect(text).to.equal('Email address')
    })

In the above code called the text method by the help of invoke command and used the result in the parameter of then
function which can be used for assertions.
	Invoke functions is used for getting the attributes of the elements and making some assertions on them

Assert Property:
when selecting dates from calendars, to check the correct dates we need to assert their properties. By using invoke 
command we can assert on the properties of the elements after clicking on them.

cy.contains('nb-card','Common Datepicker').find('input').then(input =>{
      //we have to perform a click function on the jquery method
      //so we have to wrap it to convert it into cypress format
      cy.wrap(input).click()
        cy.get('nb-calendar-day-picker').contains('14').click()
   //checking the value property whcih contains the value of the selected date
        cy.wrap(input).invoke('prop','value').should('contain','Dec 14, 2022')
    })

Check Boxes and Radio Buttons:
While clicking on radio buttons sometimes they are covered by another element. to let cypress to click on them we 
have to use the command click({force: true}) 

Timed out retrying after 30050ms: cy.click() failed because this element:

<input _ngcontent-jdh-c21="" class="native-input visually-hidden" type="radio" name="undefined" value="undefined">

is being covered by another element:

<span _ngcontent-jdh-c21="" class="outer-circle"></span>

Fix this problem, or use {force: true} to disable error checking

If there are many check boxes we can access them by using their respective index number.

cy.wrap(radioButtons)
      .eq(1) //accessing the second element by using the index number
      .check({force: true})

Asserting chekboxes by chai methods
cy.wrap(radioButtons)
      .first() // we can also use the index number to access the elements
      //to force check on elements
      .check({force: true})
      .should('be.checked')

In Cypress there is a method to check a check box but there is no methods to uncheck a check box
to Uncheck a check box we have to perform click() command on it to uncheck it.
// cy.get('[type="checkbox"]').check({force: true})
    cy.get('[type="checkbox"]').eq(0).click({force: true})
    cy.get('[type="checkbox"]').eq(1).check({force: true})

Lists and Drop Downs:
While locating an elementt we can specify multiple tags in the bracket
cy.get('nav nb-select')
Here nav is a tag and so is nb-select
The drop down elements can only be found when clicked on them once. We have to apply the click command to locate 
the drop down elements in the DOM.
After selecting any dropdown as eg: color dark we have to assert the respective css property.

Chrome supports the color formats in rgb, so we have to convert the color code into rgb explicitly.

Dropdowns always contains multiple options, then we have to assert each of them by writing the same code again and again

cy.get('nav nb-select').then(dropdown =>{
      cy.wrap(dropdown).click()
      //the below line of code will get the all the elements which are inside the dropdown
      //.options-list is the class which contains the dropdown elements
      //nb-otion tag is inside the options-list class and there are 4 of them
      //we will get all 4 of them
      cy.get('.options-list nb-option').each((listItem, index) =>{

        //in the html code the texts may contain spaces in them , using trim() command will solve them
        const itemText = listItem.text().trim()
         

        //creating an object which contains the rgb values that we will assert with that of the elements
        const colors = {
           "Light": "rgb(255, 255, 255)",
           "Dark": "rgb(34, 43, 69)",
           "Cosmic": "rgb(50, 50, 89)",
           "Corporate": "rgb(255, 255, 255)"
        }

        cy.wrap(listItem).click()

        //asserting that after clicking whether the drop down contains the text option or not
        cy.wrap(dropdown).should('contain', itemText)

        //checking whether the selected element have the respective css property or not
        cy.get('nb-layout-header nav').should('have.css', 'background-color', colors[itemText])
        //as it is a loop, it will click once again after clicking on the all 4 options
        //by this condition, it won't click on the dropdown once it clicks on all 4 of them once
        if(index < 3){
          cy.wrap(dropdown).click()
        }
      })
    })
  })

select command:
Cypress have the select command to select each of the element inside the select tag. We can select the elements 
by their text value or using their attributes.
Some times the text and value of an element can be different.

WEB Tables:

tbody is the table tag, tr is row tag, and td is column tag

//changing the age value of a table
 //yielding the result of the row where Larry is a text in the table
 //tnody is the table tag and tr is the row tag
 cy.get('tbody').contains('tr', 'Larry').then(tableRow =>{
  //clicking on the edit button of the row
  cy.wrap(tableRow).find('.nb-edit').click()
  //clearing out the age field and typing a new vale
  cy.wrap(tableRow).find('[placeholder="Age"]').clear().type('25')
  //again clicking on the check mark to save the entered data
  cy.wrap(tableRow).find('.nb-checkmark').click()
  //asserting whether the row contains the entered data or not
  //while locating there were no unique properties for the age column
  //here we used the index number of the column to assert our desired value
  cy.wrap(tableRow).find('td').eq(6).should('contain', '25')

Adding some data in the table and asserting them

//2
  //adding first name and last name in a table and asserting them

  //clicking on the button which will enable us to insert data
cy.get('thead').find('.nb-plus').click()
//finding the row and yielding the the result into a variable
  cy.get('thead').find('tr').eq(2).then(tablerow =>{
    //adding first name
    cy.wrap(tablerow).find('[placeholder="First Name"]').type('Workaholic')
    //adding last name
    cy.wrap(tablerow).find('[placeholder="Last Name"]').type('Chimp')
    //clicking on the check box after adding the values
    cy.wrap(tablerow).find('.nb-checkmark').click()
  })

  cy.get('tbody tr').first().find('td').then(tableColumn =>{
    //locating the columns by the help of their respective index numbers
    cy.wrap(tableColumn).eq(2).should('contain','Workaholic')
    cy.wrap(tableColumn).eq(3).should('contain', 'Chimp')
  })

//Adding values into the filter age field and checking whether the filteres
  //results are correct or not
 //Creating an object which will pass one by one elements into the age field
  const age = [20, 25,35, 200 ]
//pasing each element of the object as parameter
  cy.wrap(age).each( age =>{
    //adding one by one elements from the object into age field
    cy.get('thead [placeholder="Age"]').clear().type(age)
     cy.wait(500)
     //asserting each row that contains the desired value or not
     cy.get('tbody tr').each(tableRow =>{
      if( age == 200){
        cy.wrap(tableRow).should('contain', 'No data found')
      } else {
        //accessing the age column by it's index position
        cy.wrap(tableRow).find('td').eq(6).should('contain', age)
      }
     })

Web Date Pickers:

Creating a dynamic method which will select our desired date

    // it('Assert property', ()=>{
    //   cy.visit("/")
    //   cy.contains("Forms").click()
    //   cy.contains("Datepicker").click()
      
    //   cy.contains('nb-card','Common Datepicker').find('input').then(input =>{
    //     //we have to perform a click function on the jquery method
    //     //so we have to wrap it to convert it into cypress format
    //     cy.wrap(input).click()
    //       cy.get('nb-calendar-day-picker').contains('14').click()
    //       cy.wrap(input).invoke('prop','value').should('contain','Dec 14, 2022')
    //   })
    // })

    //The problem with above code is , it is hard coded, we have to change the value again
    //when we want to assert other dates or it won't work when the date changes


    function selectDayFromCurrent(day){
      //creating a date object which will contain our desired day's value
      let date = new Date()
      //getting our desired date by adding some days that we received from the day parameter from the 
      //selectDayFromCurrent methid
      date.setDate(date.getDate()+ day)
      //getting future day value
      let futureDay = date.getDate()
      //getting future month value
      let futureMonth = date.toLocaleString('default', {month: 'short'})
      //creating a variable which will store day, month, and year of our date
      //it will be useful while asserting
      let dateAssert = futureMonth+" "+futureDay+", "+date.getFullYear()
      //getting the calendar element and using it's ng-reflect-date attribute to gwt it
      cy.get('nb-calendar-navigation').invoke('attr', 'ng-reflect-date').then(dateAttribute =>{
        //in this condition we check that if the current month doesn't contain the future month
        //then it will click on the next month arrow icon until 
        //it finds the desired month
        if(!dateAttribute.includes(futureMonth)){
          cy.get('[data-name="chevron-right"]').click()
          selectDayFromCurrent(day)
          //in this condition  we check that if the current month contains the future month
          //it will select the date from the current month
        } else{
          cy.get('nb-calendar-day-picker [class="day-cell ng-star-inserted"]').contains(futureDay).click()
        }
      })
      //returning the dateAssert which can be used in asserting, if we don't return it it can 
      //not be used out side
      return dateAssert;
    }
    cy.visit("/")
    cy.contains("Forms").click()
    cy.contains("Datepicker").click()
       //getting the calendar field
    cy.contains('nb-card', 'Common Datepicker').find('input').then(input =>{
      //clicking on the calendar
      cy.wrap(input).click();
      //selecting our desired date
      let dateAssert = selectDayFromCurrent(255);
      //asserting the selected date 
      cy.wrap(input).invoke('prop', 'value').should('contain', dateAssert)
    })
  })